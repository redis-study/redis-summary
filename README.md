# redis-summary

- redis는 고성능 key-value데이터 저장소인 NoSQL(Not Only SQL)
- 문자열(string), 해시(hash), 리스트(list), 셋(set), 정렬된 셋(sorted set), 비트맵(bitmap), 하이퍼로그로그(hyperloglog)와 같은 강력한 데이터 타입 때문에 데이터 구조 서버라고도 불린다.
- 레디스는 기본적으로 모든 데이터를 메모리에 저장하기 때문에 일기와 쓰기 명령이 매우 빠르다.
- 레디스는 디스크에도 데이터를 저장할 수 있다. 레디스 데이터의 영속성(data persistance)
- help 커맨드는 도움말을 준다 keys 커맨드는 패턴과 일치하는 모든 키를 리턴하기 때문에 유용하다
- 레디스 데이터 타입의 작동 방법을 이해하면 에플리케이션 설계를 좀 더 잘할 수 있다.
- 레디스가 많은 데이터 타입을 가지고 있는 이유는 간단합니다. 하나의 크기로 모든 것을 만족시킬 수 없고, 다양한 문제가 존재하는 만큼 다양할 솔루션이 필요하기 때문이다.

## 데이터 타입
- 문자열
    - 문자열은 가장 많은 커맨드를 가지며 여러 목적으로 사용되기 때문에 레디스에서 가장 다양한 데이터 타입이다.
    - 문자열은 정수(integer) 또는 부동소수점(float), 텍스트 문자열, 비트맵 값이 기반이이고 연관 커맨드를 사용함으로써 동작한다.
    - 문자열은 문자열은 텍스트(XML, JSON, HTML, 원문 텍스트)나 정수, 부동소수점, 바이너리 데이터(비디오, 이미지, 오디오 파일)와 같이 어떠한 종류의 데이터라도 저장 가능
    - 문자열 값을 텍스트 또는 바이너리 데이터의 512MB를 초과할 수 없다.
    - 사용 예시 : 캐시 메커니즘, 자동 만료되는 캐시, Count 계산
    - Command
        - MSET, MGET : Multiple Set & Get
        - EXPIRE, TTL : set expire, check ttl
            - TTL 커맨드는 다음중 하나로 리턴한다.
                - 양의 정수 : 주어진 키가 얼마나 생존할 수 있는지 초로 보여줌
                - -2 : 키가 만료되거나 존재하지 않는 상태
                - -1 : 키가 존재하지만 만료 시간을 정하지 않음
        - (Atomic) INCR, INCRBY : 1씩 혹은 주어진 값만큼 키값를 증가시키고 증가시킨 값을 리턴한다.
        - (Atomic) DECR, DECRBY : 1씩 혹은 주어진 값만큼 키값을 감소시키고 감소시킨 값을 리턴한다.
        - (Atomic) INCRBYFLOAT, DECRBYFLOAT : 주어진 부동소수점만큼 키값을 중가 혹은 감소시키고 변경시킨 값을 리턴한다.
    - Atomic Prefix가 붙은 커맨드는 원자적 커맨드로서 서로 다른 두개의 클라이언트가 동일한 커맨드를 동시에 실행해도 동일한 값을 얻을 수 없다. 커맨드 간에는 어떠한 경합 조건도 없기 때문.
        - 레디스는 항상 한 번에 하나의 커맨드를 실행하는 싱글 스레드 기반으로 동작하기 때문에 항상 경합 조건이 발생하지 않는다.

- 리스트
    - 리스트는 간단한 콜랙션, 스택, 큐와 같이 동작할 수 있는 매우 유연한 데이터 타입이다.
    - 많은 이벤트 시스템의 큐로서 사용되는데 리스트 커맨드 역시 원자적인 특성을 갖고 있어 병렬 시스템이 큐에서 엘리먼트를 얻어낼 때 중복으로 얻지 않도록 보장해준다.
    - 레디스 리스트에 블로킹 커맨드가 존재한다. 즉 클라이언트가 비어있는 리스트에 블로킹 커맨드를 실행할 때, 클라이언트는 리스트에 새로운 엘리먼트가 추가될 때까지 기다린다는 의미다.
    - 레디스의 리스트는 Linked List라서 리스트의 처음 또는 긑에서 엘리먼트의 추가 및 삭제는 항상 O(1), 일정 시간의 성능을 가진다.
    - 즉 리스트에서 엘리먼트에 접근하는 작업은 O(N) 시간이지만 첫번째 또는 마지막 엘리먼트에는 O(1)로 접근한다.
    - 리스트의 각 엘리먼트가 list-max-ziplist-value 설정 값보다 작고, 엘리먼트 개수가 list-max-ziplist-entries 설정 값보다 작으면 리스트는 인코드 될 수 있고 메모리를 최적화 할 수 있다.
    - 리스트가 가질 수 있는 엘리먼트의 최대 개수는 2^32-1이며 40억개 이상의 엘리먼트를 가질 수 있다.
    - 리스트 실제 사용 예시는 다음과 같다. 레스큐, 셀러리, 로그스태시를 포함한 많은 툴에서 사용한다.
    - 트위터는 사용자의 최근 트윗을 저장할 때 리스트를 사용한다.
    - Command
        - LPUSH : 리스트의 처음에 데이터 추가
        - RPUSH : 리스트의 마지막에 데이터 추가
        - LLEN : 리스트의 길이를 리턴
        - LINDEX : 주어진 인덱스의 엘리먼트를 리턴 (인덱스는 0부터 시작), 리스트의 엘리먼트는 항상 왼쪽에서 오른쪽으로 접근한다. 음수로 접근할 수 있다. -1은 리스트의 끝, -2는 리스트의 끝에서 두번째 엘리먼트를 가리킨다.
        - LRANGE : 시작과 끝 인덱스를 포함시켜 주어진 인덱스 범위에 있는 모든 엘리먼트 값을 배열로 리턴한다. 인덱스는 0부터 시작하고 양수나 음수가 될 수 있다.
        - LPOP : 리스트의 첫 엘리먼트를 삭제하고 리턴
        - RPOP : 리스트의 마지막 엘리먼트를 삭제하고 리턴
        - BLPOP, BRPOP : LPOP과 RPOP을 blocking하면서 기다린다.
            - 이를 이용해서 Message Queue처럼 이용 가능
            - 해당 부분 테스트 https://spring.io/guides/gs/messaging-redis/ 에서 확인 가능

- 해시
    - 해시는 필드를 값으로 매핑할 수 있기 때문에 객체를 저장하는데 훌륭한 데이터 구조다.
    - 해시는 메모리를 효율적으로 쓸 수 있고, 데이터를 빨리 찾을 수 있게 최적화 되어 있다.
    - 해시에서 필드 이름과 값은 문자열이다. 따라서 해시는 문자열을 문자열로 매핑한다.
    - hash-max-ziplist-entries, hash-max-ziplist-value 설정을 기반으로 한다. (뒤에 설명함)
    - 해시는 내부적으로 ziplist와 hash table이 될 수 있다.
    - ziplist는 메모리 효율화에 목적을 둔 양쪽으로 연결된 리스트이다.
    - ziplist서는 정수를 일련의 문자로 저장하지 않고 실제 정수의 값으로 저장한다.
    - ziplist가 메모리 최적화가 돼 있다 할지라도 일정한 시간 내로 검색이 수행 되지는 않는다.
    - hash table에서는 일정한 시간 내로 검색은 되지만 메모리 최적화가 이루어지지 않는다.
    - Command
        - HSET HMSET : 키로 값 등록 (single, multiple)
        - HGET HMGET : 키로 값 조회 (single, multiple)
        - HINCR, HINCRBY, HDECR, HDECRBY, HINCRBYFLOAT, HDECRBYFLOAT : 주어진 정수 혹은 부동소수점 만큼 필드를 증가 감소 시킴. (HINCR, HDECR은 1씩 증가 감소)
        - HDEL : 해시에서 필드를 삭제
        - HGETALL : 모든 필드 조회
        - HKEYS : 모든 필드 key 조회
        - HVALS : 모든 필드 value 조회


- 셋
    - 순서가 없고 동일한 물자열이 없는 콜렉션
    - 일부 커맨드(엘리먼트 추가 및 삭제, 검색의 성능 속도는 항상 O(1)이다)를 최적화해야 하기 때문에 해시 테이블로 구현
    - 셋의 모든 엘리먼트 값이 정수(integer)면 셋 메모리 영역은 줄얻르고 전체 엘리먼트 갯수는 set-max-intset-entries 설정 값만큼 커질 수 있다.
    - 셋이 가질 수 있는 엘리먼트의 최대 개수는 2^32-1이다. 즉, 한 셋에 40억개 이상의 엘리먼트를 저장할 수 있따.
    - 셋은 데이터 필터링, 데이터 그룹핑, 엘리먼트십 확인 등에 사용하기 좋다
    - Command
        - SADD : 셋에 하나 이상의 엘리먼트를 추가한ㄷ.
        - SINTER : 하나 이상의 셋을 받아 모든 셋에 공통으로 존재하는 엘리먼트를 배열로 리턴
        - SDIFF : 하나 이상의 셋을 받고 첫번째 셋의 모든 엘리멘트중 그 뒤에 따르는 셋에 존재하지 않는 엘리멘터를 배열로 리턴
        - SUNION : 하나 이상의 셋을 받고 모든 셋의 엘리먼트를 하나로 모아 리턴한다. 리턴된 결과에는 중복된 엘리먼트가 존재하지 않는다.
        - SRANDMEMBER : 셋에서 엘리먼트를 무작위로 뽑은 후 리턴한다.
        - SISMEMBER : 셋에 엘리먼트가 존재하는지 확인한다.
        - SREM : 주어진 엘리먼트를 셋에서 삭제한 후 셋에 남아있는 엘리먼트의 개수를 리턴한다.
        - SCARD : 셋의 엘리먼트 갯수를 리턴한다. (cardinality)
        - SMEMBERS : 셋의 모든 엘리먼트를 배열로 리턴

- 정렬된 셋 (sorted set)
    - 정렬된 셋은 셋과 비슷하지만, 정렬된 셋의 모든 엘리먼트는 연관 점수를 가진다.
    - 즉 sorted set은 점수로 정렬된, 중복 문자열이 없는 콜랙션이다.
    - 반복 점수를 가진 엘리먼트를 가질 수 있다. 이런 경우에 반복 엘리먼트를 사전 편집 순서대로 정렬할 수 있다.
    - 정렬된 셋 커맨드는 빠른 편이지만 점수로 엘리먼트를 비교해야 하기 때문에 셋 커맨드보다 빠르지 않다.
    - 정렬된 셋에서 엘리먼트의 추가 및 삭제, 변경 성능은 O(logN)이며 여기서 N은 정렬된 셋의 엘리먼트 개수다.
    - 정렬된 셋의 내부 구현은 2개의 분리된 데이터 구조로 되어 있다.
        1. skiplist : 순서대로 정렬된 엘리먼트를 빠르게 검색
        2. ziplist : zset-max-ziplist-entries와 zset-max-ziplist-value 설정을 기반으로 함
    - sorted set은 고객 서비스 실시간 대기 목록 만들기, 수백만개의 단어를 사용하는 자동 완성 시스템 만들기 등에서 사용 가능하다.
    - Command
        - ZADD : sorted set에 하나 이상의 엘리먼트 추가, 만약 해당 엘리먼트가 이미 존재하면 무시하고 추가된 엘리먼트의 개수를 리턴
        - ZRANGE, ZRANGEBYLEX, ZRANGEBYSCORE, ZREVRANGE, ZREVRANGEBYLEX, ZREVRANGEBYSCORE : 범위를 읽어오는데 사용
        - WITHSCORES : 범위 커맨드의 옵션, 엘리먼트의 점수를 함께 리턴
        - ZREM : 정렬된 셋에서 엘리먼트를 삭제
        - ZSCORE : 엘리먼트의 점수를 리턴한다.
        - ZRANK : 등수가 낮은 순으로 정렬된 엘리먼트의 등수를 리턴한다.
        - ZREVRANK : 등수가 높은 순에서 낮은 순으로 정렬된 엘리먼트의 등수를 리턴한다.

- 비트맵
    - 비트맵은 레디스의 실제 데이터 타입이 아니다. 내부적으로 비트맵은 문자열이다.
    - 비트맵은 문자열의 bit 연산자 집합이라고 말할 수 있다.
    - 그러나 레디스는 문자열을 비트맵으로 제어할 수 있는 커맨드를 제공하기 때문에, 비트맵을 데이터 타입을 간주한다.
    - 비트맵은 비트 배열(bit array) 또는 배트 셋(bit set)으로 알려져 있다.
    - 비트맵은 개별 비트를 0 또는 1로 저장할 수 있는 비트 열이다.
    - 비트맵을 0과 1로 구성된 배열로 생각할 수 있다.
    - 레디스 문서는 비트맵 인덱스를 오프셋으로 나타낸다.
    - 애플리케이션 도메인은 개별 비트맵 인덱스가 무엇을 의미하는지 지시한다.
    - 비트맵은 메모리 효율이 좋고 빠른 검색을 지원하며, 2^32비트(40억비트 이상)까지 저장할 수 있다.
    - true false값을 단순히 저장할 때 쓸만하다
    - Command
        - SETBIT : 비트맵 오프셋에 값을 저장
        - GETBIT : 비트맵 오프셋 값을 리턴
        - BITCOUNT: 비트맵에 1로 표시된 모든 비트의 개수를 리턴
        - BITOP : 대상 키, 비트 연산, 해당 연산에 적용하고 결과를 대상 키에 저장할 키 목록 (OR, AND, XOR, NOT)

- 하이퍼로그로그
    - 레디스의 실제 데이터 타입이 아니다. 하이퍼로그로그는 개념적으로는 알고리즘이다.
    - 셋에 존재하는 고유 엘리먼트 개수를 아주 좋은 근사치로 제공하기 위해 확률화를 사용하는 알고리즘이다.
    - 하나의 키당 아주 작은 메모리(최대12KB)를 사용하며, 항상 O(1)로만 동작하기 때문에 매력적이다.
    - 기술적으로는 하이퍼로그로그가 실제 데이터 타입이 아닐지라도, 레디스는 하이퍼로그로그 알고리즘을 사용해 셋의 개수를 계산하기 위한 문자열 제어하는 커멘드를 제공하기 때문에 데이터타입처럼 다룰것이다.
    - 하이퍼로그로그는 100%의 정확도를 보장하지 않는 확률적인 알고리즘이다.
    - 하이퍼로그로그의 레디스 구현은 0.81퍼센트의 표준오차를 가진다.
    - 이론상 셀 수 있는 셋의 개수 제한은 사실 없다.
    - 하이퍼로그로그 논문(Philippe Flajolet, Eric Fusy, Oliver Gandouet, Frederic Meunier의 공동농문 'The analysis of a newar-optiomal cardinality estimation algorithm)에서 하이퍼로그로그 알고리즘이 처음으로 설명됐다.
    - 하이퍼로그로그에는 PFADD, PFCOUNT, PFMERGE 세 개의 커맨드만 존재한다.
    - 종종 고유 개수를 계산하기 위해, 현재 계산 중인 셋의 엘리먼트 수에 비례하는 메모리가 있어야 한다.
    - 하이퍼로그로그는 좋은 성능, 낮은 계산 비용, 적은 메모리 양으로 해당 문제를 해결한다.
    - 그러나 하이퍼로그로그는 100퍼센트 정확하지는 않다. 그럼에도 불구하고 일부 상황에서는 99.19퍼센트정도라면 충분히 괜찮을 수 있다.
    - 하이퍼로그로그는 웹사이트 고유 방문자 수 계산, 특정 날짜 또는 시간에 웹사이트에서 검색한 고유 키워드 개수 계산, 사용자가 사용한 고유 해시태그 개수 계산, 책에 나오는 고유 단어 개수 계산 등에 쓰이면 좋겠다.
